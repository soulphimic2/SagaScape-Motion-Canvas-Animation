import {
  Direction,
  Vector2,
  all,
  clampRemap,
  createSignal,
  easeInOutCubic,
  linear,
  useScene,
  waitFor
} from "./chunk-PCLTR6CQ.js";

// node_modules/@motion-canvas/core/lib/transitions/useTransition.js
function useTransition(current, previous, previousOnTop) {
  if (previous == null) {
    previous = () => {
    };
  }
  const scene = useScene();
  const prior = scene.previous;
  scene.previousOnTop = previousOnTop ?? false;
  const unsubPrev = prior == null ? void 0 : prior.lifecycleEvents.onBeforeRender.subscribe(previous);
  const unsubNext = scene.lifecycleEvents.onBeforeRender.subscribe(current);
  scene.enterInitial();
  return () => {
    scene.enterAfterTransitionIn();
    unsubPrev == null ? void 0 : unsubPrev();
    unsubNext();
  };
}

// node_modules/@motion-canvas/core/lib/transitions/fadeTransition.js
function* fadeTransition(duration = 0.6) {
  const progress = createSignal(0);
  const endTransition = useTransition((ctx) => {
    ctx.globalAlpha = progress();
  });
  yield* progress(1, duration);
  endTransition();
}

// node_modules/@motion-canvas/core/lib/transitions/slideTransition.js
function* slideTransition(direction = Direction.Top, duration = 0.6) {
  const size = useScene().getRealSize();
  const position = size.getOriginOffset(direction).scale(2);
  const previousPosition = Vector2.createSignal();
  const currentPosition = Vector2.createSignal(position);
  const endTransition = useTransition((ctx) => ctx.translate(currentPosition.x(), currentPosition.y()), (ctx) => ctx.translate(previousPosition.x(), previousPosition.y()));
  yield* all(previousPosition(position.scale(-1), duration), currentPosition(Vector2.zero, duration));
  endTransition();
}

// node_modules/@motion-canvas/core/lib/transitions/waitTransition.js
function* waitTransition(duration = 0.6, previousOnTop = true) {
  const endTransition = useTransition(() => {
  }, void 0, previousOnTop);
  yield* waitFor(duration);
  endTransition();
}

// node_modules/@motion-canvas/core/lib/transitions/zoomInTransition.js
function* zoomInTransition(area, duration = 0.6) {
  const scale = useScene().getRealSize().div(area.size);
  const currentPosition = Vector2.createSignal(area.position);
  const currentScale = Vector2.createSignal(Vector2.one.div(scale));
  const previousPosition = Vector2.createSignal(0);
  const previousScale = Vector2.createSignal(1);
  const alpha = createSignal(0);
  const endTransition = useTransition((ctx) => {
    ctx.globalAlpha = clampRemap(0.1, 0.5, 0, 1, alpha());
    ctx.translate(currentPosition.x(), currentPosition.y());
    ctx.scale(currentScale.x(), currentScale.y());
  }, (ctx) => {
    ctx.globalAlpha = clampRemap(0.5, 0.9, 1, 0, alpha());
    ctx.translate(previousPosition.x(), previousPosition.y());
    ctx.scale(previousScale.x(), previousScale.y());
  });
  const timing = (v) => easeInOutCubic(v * v);
  yield* all(currentPosition(Vector2.zero, duration, timing), previousPosition(area.position.flipped.mul(scale), duration, timing), currentScale(1, duration, timing), previousScale(scale, duration, timing), alpha(1, duration, linear));
  endTransition();
}

// node_modules/@motion-canvas/core/lib/transitions/zoomOutTransition.js
function* zoomOutTransition(area, duration = 0.6) {
  const scale = useScene().getRealSize().div(area.size);
  const currentPosition = Vector2.createSignal(area.position.flipped.mul(scale));
  const currentScale = Vector2.createSignal(scale);
  const previousPosition = Vector2.createSignal(0);
  const previousScale = Vector2.createSignal(1);
  const alpha = createSignal(0);
  const endTransition = useTransition((ctx) => {
    ctx.globalAlpha = clampRemap(0.1, 0.5, 0, 1, alpha());
    ctx.translate(currentPosition.x(), currentPosition.y());
    ctx.scale(currentScale.x(), currentScale.y());
  }, (ctx) => {
    ctx.globalAlpha = clampRemap(0.5, 0.9, 1, 0, alpha());
    ctx.translate(previousPosition.x(), previousPosition.y());
    ctx.scale(previousScale.x(), previousScale.y());
  });
  const timing = (v) => easeInOutCubic(Math.sqrt(v));
  yield* all(currentPosition(Vector2.zero, duration, timing), previousPosition(area.position, duration, timing), currentScale(1, duration, timing), previousScale(Vector2.one.div(scale), duration, timing), alpha(1, duration, linear));
  endTransition();
}

export {
  useTransition,
  fadeTransition,
  slideTransition,
  waitTransition,
  zoomInTransition,
  zoomOutTransition
};
//# sourceMappingURL=chunk-M23V7U2B.js.map
